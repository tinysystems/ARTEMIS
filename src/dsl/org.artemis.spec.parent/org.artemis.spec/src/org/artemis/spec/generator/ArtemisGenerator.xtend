/*
 * generated by Xtext 2.25.0
 */
package org.artemis.spec.generator

import org.artemis.spec.artemis.ArtemisModel
import org.artemis.spec.artemis.Collect
import org.artemis.spec.artemis.MaxDuration
import org.artemis.spec.artemis.MaxTries
import org.artemis.spec.artemis.Mitd
import org.artemis.spec.artemis.Period
import org.artemis.spec.artemis.RestartPath
import org.artemis.spec.artemis.RestartTask
import org.artemis.spec.artemis.SkipPath
import org.artemis.spec.artemis.SkipTask
import org.artemis.spec.artemis.Task
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ArtemisGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	    val root = resource.allContents.head as ArtemisModel
	    fsa.generateFile(resource.URI.trimFileExtension.lastSegment + ".machine", artemis2SM(root))
	}
	
	def artemis2SM(ArtemisModel model)
	'''
	«FOR taskProperties : model.taskProperties»
	«FOR property : taskProperties.properties»
	«property2Machine(property, taskProperties.task, taskProperties.properties.indexOf(property))»
	
	«ENDFOR»
	«ENDFOR»
	'''
	
	def dispatch property2Machine(Period periodProperty, Task task, int index)
	'''
	machine «task.name»_«index» {
	    variables
	    real period = «periodProperty.period»
	    real jitter = 20.0
	    real start
	    int counter = 1
	    int nrTries = 1
	    
	    initial state NotStarted {
	        on startTask(«task.name», t)
	            start = t
	        next state: WaitTaskEnd
	    }
	    
	    state WaitTaskEnd {
	        on endTask(«task.name», t) guard: t <= start + (counter * period) + jitter
	        next state: WaitTaskStart
	        
	        on anyEvent(t) guard: (t >= start + (counter * period) + jitter) and (nrTries < «periodProperty.maxAttempts»)
	            counter = 1
	            nrTries = nrTries + 1
	            «onFailAction(periodProperty.onFailAction)»
	        next state: NotStarted
	        
	        on anyEvent(t) guard: (t >= start + (counter * period) + jitter) and (nrTries == «periodProperty.maxAttempts»)
	            counter = 1
	            nrTries = 1
	            «onFailAction(periodProperty.onFailMaxAttemptAction)»
	        next state: NotStarted //or finish and discard the entire monitor?
	    }
	    
	    state WaitTaskStart {
	        on startTask(«task.name», t) guard: (t <= start + (counter * period) + jitter) and
	                                  (t >= start + (counter * period) - jitter)
	            counter = counter + 1
	        next state: WaitTaskEnd
	        
	        on anyEvent(t) guard: (t >= start + (counter * period) + jitter) and nrTries < «periodProperty.maxAttempts»
	            counter = 1
	            nrTries = nrTries + 1
	            «onFailAction(periodProperty.onFailAction)»
	        next state: NotStarted
	
	        on anyEvent(t) guard: (t >= start + (counter * period) + jitter) and nrTries == «periodProperty.maxAttempts»
	            counter = 1
	            nrTries = 1
	            «onFailAction(periodProperty.onFailMaxAttemptAction)»
	        next state: NotStarted
	        
	        on startTask(«task.name», t) guard: (t < start + (counter * period) - jitter) and nrTries < «periodProperty.maxAttempts»
	            counter = 1
	            nrTries = nrTries + 1
	            «onFailAction(periodProperty.onFailAction)»
	        next state: NotStarted
	        
	        on startTask(«task.name», t) guard: (t < start + (counter * period) - jitter) and nrTries == «periodProperty.maxAttempts»
	            counter = 1
	            nrTries = 1
	            «onFailAction(periodProperty.onFailMaxAttemptAction)»
	        next state: NotStarted
	        
	    }
	}
	'''
	
	def dispatch property2Machine(MaxTries maxTriesProperty, Task task, int index)
    '''
    machine «task.name»_«index» {
        variables
        int maxTries = «maxTriesProperty.nrTries»
        int i
        
        initial state NotStarted {
            on startTask(«task.name», t)
                i = 1
            next state: Started
        }
        
        state Started {
            on startTask(«task.name», t) guard: i < maxTries
                i = i + 1
            next state: Started
                    
            on startTask(«task.name», t) guard: i == maxTries
                «onFailAction(maxTriesProperty.onFailAction)»
            next state: NotStarted
                    
            on endTask(«task.name», t)
            next state: NotStarted
        }
    }
    '''
    
    def dispatch property2Machine(MaxDuration maxDurationProperty, Task task, int index)
    '''
    machine «task.name»_«index» {
        variables
        real d = «maxDurationProperty.maxDuration»
        real start
        
        initial state NotStarted {
                on startTask(«task.name», t)
                    start = t
                next state: Started
            }
            
            state Started {
                on endTask(«task.name», t) guard: t - start <= d
                next state: NotStarted
                
                on anyEvent(t) guard: t - start > d
                    «onFailAction(maxDurationProperty.onFailAction)»
                next state: NotStarted
            }
    }
    '''
    
    def dispatch property2Machine(Collect collectProperty, Task task, int index)
    '''
    machine «task.name»_«index» {
        variables
        int i = 0
        
        initial state Idle {
            on startTask(«task.name», t) guard: i == «collectProperty.nrItems»
                i = 0
            next state: Idle
            
            on startTask(«task.name», t) guard: i != «collectProperty.nrItems»
                i = 0
                «onFailAction(collectProperty.onFailAction)»
            next state: Idle
            
            on endTask(«collectProperty.dependsOn.name», t)
                i = i + 1
            next state: Idle
        }
    }
    '''
    
    def dispatch property2Machine(Mitd mitdProperty, Task task, int index)
    '''
    machine «task.name»_«index» {
        variables
        real d = «mitdProperty.duration»
        int i = 1
        real end«mitdProperty.dependsOn.name»
        
        initial state WaitEnd«mitdProperty.dependsOn.name» {
            on endTask(«mitdProperty.dependsOn.name», t)
                end«mitdProperty.dependsOn.name» = t
            next state: WaitStart«task.name»
        }
        
        state WaitStart«task.name» {
            on startTask(«task.name», t) guard: t - end«mitdProperty.dependsOn.name» <= d
                i = 1
            next state: WaitEnd«mitdProperty.dependsOn.name»
            
            on anyEvent(t) guard: t - end«mitdProperty.dependsOn.name» > d and i < «mitdProperty.maxAttempts»
                i = i + 1
                «onFailAction(mitdProperty.onFailAction)»
            next state: WaitEnd«mitdProperty.dependsOn.name»
            
            on anyEvent(t) guard: t - end«mitdProperty.dependsOn.name» > d and i == «mitdProperty.maxAttempts»
                «onFailAction(mitdProperty.onFailMaxAttemptAction)»
            next state: WaitEnd«mitdProperty.dependsOn.name»
        }
    }
    '''
    
    def dispatch onFailAction(RestartPath rp)
    '''restartPath«IF rp.path > 0» Path: «rp.path»«ENDIF»'''
    
    def dispatch onFailAction(SkipPath sp)
    '''skipPath«IF sp.path > 0» Path: «sp.path»«ENDIF»'''
    
    def dispatch onFailAction(RestartTask rt)
    '''restartTask'''
    
    def dispatch onFailAction(SkipTask st)
    '''skipTask'''
        
}
