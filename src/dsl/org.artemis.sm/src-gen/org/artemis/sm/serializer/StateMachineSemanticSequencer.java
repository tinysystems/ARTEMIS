/*
 * generated by Xtext 2.25.0
 */
package org.artemis.sm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.artemis.base.base.Array;
import org.artemis.base.base.BasePackage;
import org.artemis.base.base.EnumElement;
import org.artemis.base.base.EnumTypeDecl;
import org.artemis.base.base.Model;
import org.artemis.base.base.SimpleTypeDecl;
import org.artemis.base.base.TypeRef;
import org.artemis.base.serializer.BaseSemanticSequencer;
import org.artemis.sm.services.StateMachineGrammarAccess;
import org.artemis.sm.stateMachine.AnyEvent;
import org.artemis.sm.stateMachine.AssignmentAction;
import org.artemis.sm.stateMachine.EndTask;
import org.artemis.sm.stateMachine.ExpressionAddition;
import org.artemis.sm.stateMachine.ExpressionAnd;
import org.artemis.sm.stateMachine.ExpressionBracket;
import org.artemis.sm.stateMachine.ExpressionConstantBool;
import org.artemis.sm.stateMachine.ExpressionConstantInt;
import org.artemis.sm.stateMachine.ExpressionConstantReal;
import org.artemis.sm.stateMachine.ExpressionConstantString;
import org.artemis.sm.stateMachine.ExpressionDivision;
import org.artemis.sm.stateMachine.ExpressionEqual;
import org.artemis.sm.stateMachine.ExpressionGeq;
import org.artemis.sm.stateMachine.ExpressionGreater;
import org.artemis.sm.stateMachine.ExpressionLeq;
import org.artemis.sm.stateMachine.ExpressionLess;
import org.artemis.sm.stateMachine.ExpressionMaximum;
import org.artemis.sm.stateMachine.ExpressionMinimum;
import org.artemis.sm.stateMachine.ExpressionMinus;
import org.artemis.sm.stateMachine.ExpressionMultiply;
import org.artemis.sm.stateMachine.ExpressionNEqual;
import org.artemis.sm.stateMachine.ExpressionNot;
import org.artemis.sm.stateMachine.ExpressionOr;
import org.artemis.sm.stateMachine.ExpressionPlus;
import org.artemis.sm.stateMachine.ExpressionPower;
import org.artemis.sm.stateMachine.ExpressionSubtraction;
import org.artemis.sm.stateMachine.ExpressionVariable;
import org.artemis.sm.stateMachine.Monitor;
import org.artemis.sm.stateMachine.RestartPath;
import org.artemis.sm.stateMachine.RestartTask;
import org.artemis.sm.stateMachine.SkipPath;
import org.artemis.sm.stateMachine.SkipTask;
import org.artemis.sm.stateMachine.StartTask;
import org.artemis.sm.stateMachine.State;
import org.artemis.sm.stateMachine.StateMachine;
import org.artemis.sm.stateMachine.StateMachinePackage;
import org.artemis.sm.stateMachine.Transition;
import org.artemis.sm.stateMachine.TypedVariable;
import org.artemis.sm.stateMachine.UntypedVariable;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class StateMachineSemanticSequencer extends BaseSemanticSequencer {

	@Inject
	private StateMachineGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BasePackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case BasePackage.ENUM_ELEMENT:
				sequence_EnumElement(context, (EnumElement) semanticObject); 
				return; 
			case BasePackage.ENUM_TYPE_DECL:
				sequence_EnumTypeDecl(context, (EnumTypeDecl) semanticObject); 
				return; 
			case BasePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BasePackage.SIMPLE_TYPE_DECL:
				sequence_SimpleTypeDecl(context, (SimpleTypeDecl) semanticObject); 
				return; 
			case BasePackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			}
		else if (epackage == StateMachinePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StateMachinePackage.ANY_EVENT:
				sequence_AnyEvent(context, (AnyEvent) semanticObject); 
				return; 
			case StateMachinePackage.ASSIGNMENT_ACTION:
				sequence_AssignmentAction(context, (AssignmentAction) semanticObject); 
				return; 
			case StateMachinePackage.END_TASK:
				sequence_EndTask(context, (EndTask) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_ADDITION:
				sequence_ExpressionLevel4(context, (ExpressionAddition) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_AND:
				sequence_ExpressionLevel1(context, (ExpressionAnd) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_BRACKET:
				sequence_ExpressionBracket(context, (ExpressionBracket) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_CONSTANT_BOOL:
				sequence_ExpressionConstantBool(context, (ExpressionConstantBool) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_CONSTANT_INT:
				sequence_ExpressionConstantInt(context, (ExpressionConstantInt) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_CONSTANT_REAL:
				sequence_ExpressionConstantReal(context, (ExpressionConstantReal) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_CONSTANT_STRING:
				sequence_ExpressionConstantString(context, (ExpressionConstantString) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_DIVISION:
				sequence_ExpressionLevel5(context, (ExpressionDivision) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_EQUAL:
				sequence_ExpressionLevel2(context, (ExpressionEqual) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_GEQ:
				sequence_ExpressionLevel3(context, (ExpressionGeq) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_GREATER:
				sequence_ExpressionLevel3(context, (ExpressionGreater) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_LEQ:
				sequence_ExpressionLevel3(context, (ExpressionLeq) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_LESS:
				sequence_ExpressionLevel3(context, (ExpressionLess) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_MAXIMUM:
				sequence_ExpressionLevel5(context, (ExpressionMaximum) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_MINIMUM:
				sequence_ExpressionLevel5(context, (ExpressionMinimum) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_MINUS:
				sequence_ExpressionMinus(context, (ExpressionMinus) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_MULTIPLY:
				sequence_ExpressionLevel5(context, (ExpressionMultiply) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_NEQUAL:
				sequence_ExpressionLevel2(context, (ExpressionNEqual) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_NOT:
				sequence_ExpressionNot(context, (ExpressionNot) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_OR:
				sequence_ExpressionLevel1(context, (ExpressionOr) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_PLUS:
				sequence_ExpressionPlus(context, (ExpressionPlus) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_POWER:
				sequence_ExpressionLevel6(context, (ExpressionPower) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_SUBTRACTION:
				sequence_ExpressionLevel4(context, (ExpressionSubtraction) semanticObject); 
				return; 
			case StateMachinePackage.EXPRESSION_VARIABLE:
				sequence_ExpressionVariable(context, (ExpressionVariable) semanticObject); 
				return; 
			case StateMachinePackage.MONITOR:
				sequence_Monitor(context, (Monitor) semanticObject); 
				return; 
			case StateMachinePackage.RESTART_PATH:
				sequence_RestartPath(context, (RestartPath) semanticObject); 
				return; 
			case StateMachinePackage.RESTART_TASK:
				sequence_RestartTask(context, (RestartTask) semanticObject); 
				return; 
			case StateMachinePackage.SKIP_PATH:
				sequence_SkipPath(context, (SkipPath) semanticObject); 
				return; 
			case StateMachinePackage.SKIP_TASK:
				sequence_SkipTask(context, (SkipTask) semanticObject); 
				return; 
			case StateMachinePackage.START_TASK:
				sequence_StartTask(context, (StartTask) semanticObject); 
				return; 
			case StateMachinePackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case StateMachinePackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case StateMachinePackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case StateMachinePackage.TYPED_VARIABLE:
				sequence_TypedVariable(context, (TypedVariable) semanticObject); 
				return; 
			case StateMachinePackage.UNTYPED_VARIABLE:
				sequence_UntypedVariable(context, (UntypedVariable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Event returns AnyEvent
	 *     AnyEvent returns AnyEvent
	 *
	 * Constraint:
	 *     timeVar=UntypedVariable
	 */
	protected void sequence_AnyEvent(ISerializationContext context, AnyEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnyEventAccess().getTimeVarUntypedVariableParserRuleCall_2_0(), semanticObject.getTimeVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns AssignmentAction
	 *     AssignmentAction returns AssignmentAction
	 *
	 * Constraint:
	 *     (var=[Variable|ID] expr=Expression)
	 */
	protected void sequence_AssignmentAction(ISerializationContext context, AssignmentAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.ASSIGNMENT_ACTION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.ASSIGNMENT_ACTION__VAR));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.ASSIGNMENT_ACTION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.ASSIGNMENT_ACTION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentActionAccess().getVarVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(StateMachinePackage.Literals.ASSIGNMENT_ACTION__VAR, false));
		feeder.accept(grammarAccess.getAssignmentActionAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns EndTask
	 *     EndTask returns EndTask
	 *
	 * Constraint:
	 *     (task=ID timeVar=UntypedVariable)
	 */
	protected void sequence_EndTask(ISerializationContext context, EndTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.END_TASK__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.END_TASK__TASK));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndTaskAccess().getTaskIDTerminalRuleCall_2_0(), semanticObject.getTask());
		feeder.accept(grammarAccess.getEndTaskAccess().getTimeVarUntypedVariableParserRuleCall_4_0(), semanticObject.getTimeVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionBracket
	 *     ExpressionLevel1 returns ExpressionBracket
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel2 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel3 returns ExpressionBracket
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionBracket
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionBracket
	 *     ExpressionLevel4 returns ExpressionBracket
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel5 returns ExpressionBracket
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionBracket
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionBracket
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionBracket
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionBracket
	 *     ExpressionLevel6 returns ExpressionBracket
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionBracket
	 *     ExpressionLevel7 returns ExpressionBracket
	 *     ExpressionLevel8 returns ExpressionBracket
	 *     ExpressionBracket returns ExpressionBracket
	 *
	 * Constraint:
	 *     sub=Expression
	 */
	protected void sequence_ExpressionBracket(ISerializationContext context, ExpressionBracket semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_BRACKET__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_BRACKET__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionBracketAccess().getSubExpressionParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionConstantBool
	 *     ExpressionLevel1 returns ExpressionConstantBool
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionConstantBool
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel2 returns ExpressionConstantBool
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionConstantBool
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel3 returns ExpressionConstantBool
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionConstantBool
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionConstantBool
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionConstantBool
	 *     ExpressionLevel4 returns ExpressionConstantBool
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionConstantBool
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel5 returns ExpressionConstantBool
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionConstantBool
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionConstantBool
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionConstantBool
	 *     ExpressionLevel6 returns ExpressionConstantBool
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionConstantBool
	 *     ExpressionLevel7 returns ExpressionConstantBool
	 *     ExpressionLevel8 returns ExpressionConstantBool
	 *     ExpressionConstantBool returns ExpressionConstantBool
	 *
	 * Constraint:
	 *     value=BOOL_LITERAL
	 */
	protected void sequence_ExpressionConstantBool(ISerializationContext context, ExpressionConstantBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionConstantBoolAccess().getValueBOOL_LITERALTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionConstantInt
	 *     ExpressionLevel1 returns ExpressionConstantInt
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel2 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel3 returns ExpressionConstantInt
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionConstantInt
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionConstantInt
	 *     ExpressionLevel4 returns ExpressionConstantInt
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel5 returns ExpressionConstantInt
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionConstantInt
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionConstantInt
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionConstantInt
	 *     ExpressionLevel6 returns ExpressionConstantInt
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionConstantInt
	 *     ExpressionLevel7 returns ExpressionConstantInt
	 *     ExpressionLevel8 returns ExpressionConstantInt
	 *     ExpressionConstantInt returns ExpressionConstantInt
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ExpressionConstantInt(ISerializationContext context, ExpressionConstantInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionConstantIntAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionConstantReal
	 *     ExpressionLevel1 returns ExpressionConstantReal
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionConstantReal
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel2 returns ExpressionConstantReal
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionConstantReal
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel3 returns ExpressionConstantReal
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionConstantReal
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionConstantReal
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionConstantReal
	 *     ExpressionLevel4 returns ExpressionConstantReal
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionConstantReal
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel5 returns ExpressionConstantReal
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionConstantReal
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionConstantReal
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionConstantReal
	 *     ExpressionLevel6 returns ExpressionConstantReal
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionConstantReal
	 *     ExpressionLevel7 returns ExpressionConstantReal
	 *     ExpressionLevel8 returns ExpressionConstantReal
	 *     ExpressionConstantReal returns ExpressionConstantReal
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_ExpressionConstantReal(ISerializationContext context, ExpressionConstantReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_REAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_REAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionConstantRealAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionConstantString
	 *     ExpressionLevel1 returns ExpressionConstantString
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionConstantString
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionConstantString
	 *     ExpressionLevel2 returns ExpressionConstantString
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionConstantString
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionConstantString
	 *     ExpressionLevel3 returns ExpressionConstantString
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionConstantString
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionConstantString
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionConstantString
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionConstantString
	 *     ExpressionLevel4 returns ExpressionConstantString
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionConstantString
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionConstantString
	 *     ExpressionLevel5 returns ExpressionConstantString
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionConstantString
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionConstantString
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionConstantString
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionConstantString
	 *     ExpressionLevel6 returns ExpressionConstantString
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionConstantString
	 *     ExpressionLevel7 returns ExpressionConstantString
	 *     ExpressionLevel8 returns ExpressionConstantString
	 *     ExpressionConstantString returns ExpressionConstantString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ExpressionConstantString(ISerializationContext context, ExpressionConstantString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_CONSTANT_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionConstantStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionAnd
	 *     ExpressionLevel1 returns ExpressionAnd
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionAnd
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionAnd
	 *
	 * Constraint:
	 *     (left=ExpressionLevel1_ExpressionAnd_1_0_0 right=ExpressionLevel2)
	 */
	protected void sequence_ExpressionLevel1(ISerializationContext context, ExpressionAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel1Access().getExpressionAndLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel1Access().getRightExpressionLevel2ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionOr
	 *     ExpressionLevel1 returns ExpressionOr
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionOr
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionOr
	 *
	 * Constraint:
	 *     (left=ExpressionLevel1_ExpressionOr_1_1_0 right=ExpressionLevel2)
	 */
	protected void sequence_ExpressionLevel1(ISerializationContext context, ExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel1Access().getExpressionOrLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel1Access().getRightExpressionLevel2ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionEqual
	 *     ExpressionLevel1 returns ExpressionEqual
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionEqual
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionEqual
	 *     ExpressionLevel2 returns ExpressionEqual
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionEqual
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionEqual
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionEqual_1_0_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionEqualLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionNEqual
	 *     ExpressionLevel1 returns ExpressionNEqual
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionNEqual
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionNEqual
	 *     ExpressionLevel2 returns ExpressionNEqual
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionNEqual
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionNEqual
	 *
	 * Constraint:
	 *     (left=ExpressionLevel2_ExpressionNEqual_1_1_0 right=ExpressionLevel3)
	 */
	protected void sequence_ExpressionLevel2(ISerializationContext context, ExpressionNEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_NEQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_NEQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_NEQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_NEQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel2Access().getExpressionNEqualLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel2Access().getRightExpressionLevel3ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionGeq
	 *     ExpressionLevel1 returns ExpressionGeq
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionGeq
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionGeq
	 *     ExpressionLevel2 returns ExpressionGeq
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionGeq
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionGeq
	 *     ExpressionLevel3 returns ExpressionGeq
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionGeq
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionGeq
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionGeq
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionGeq
	 *
	 * Constraint:
	 *     (left=ExpressionLevel3_ExpressionGeq_1_0_0 right=ExpressionLevel4)
	 */
	protected void sequence_ExpressionLevel3(ISerializationContext context, ExpressionGeq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_GEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_GEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_GEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_GEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel3Access().getExpressionGeqLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel3Access().getRightExpressionLevel4ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionGreater
	 *     ExpressionLevel1 returns ExpressionGreater
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionGreater
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionGreater
	 *     ExpressionLevel2 returns ExpressionGreater
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionGreater
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionGreater
	 *     ExpressionLevel3 returns ExpressionGreater
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionGreater
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionGreater
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionGreater
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionGreater
	 *
	 * Constraint:
	 *     (left=ExpressionLevel3_ExpressionGreater_1_1_0 right=ExpressionLevel4)
	 */
	protected void sequence_ExpressionLevel3(ISerializationContext context, ExpressionGreater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel3Access().getExpressionGreaterLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel3Access().getRightExpressionLevel4ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionLeq
	 *     ExpressionLevel1 returns ExpressionLeq
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionLeq
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionLeq
	 *     ExpressionLevel2 returns ExpressionLeq
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionLeq
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionLeq
	 *     ExpressionLevel3 returns ExpressionLeq
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionLeq
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionLeq
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionLeq
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionLeq
	 *
	 * Constraint:
	 *     (left=ExpressionLevel3_ExpressionLeq_1_2_0 right=ExpressionLevel4)
	 */
	protected void sequence_ExpressionLevel3(ISerializationContext context, ExpressionLeq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_LEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_LEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_LEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_LEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel3Access().getExpressionLeqLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel3Access().getRightExpressionLevel4ParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionLess
	 *     ExpressionLevel1 returns ExpressionLess
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionLess
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionLess
	 *     ExpressionLevel2 returns ExpressionLess
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionLess
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionLess
	 *     ExpressionLevel3 returns ExpressionLess
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionLess
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionLess
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionLess
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionLess
	 *
	 * Constraint:
	 *     (left=ExpressionLevel3_ExpressionLess_1_3_0 right=ExpressionLevel4)
	 */
	protected void sequence_ExpressionLevel3(ISerializationContext context, ExpressionLess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_LESS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_LESS__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_LESS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_LESS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel3Access().getExpressionLessLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel3Access().getRightExpressionLevel4ParserRuleCall_1_3_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionAddition
	 *     ExpressionLevel1 returns ExpressionAddition
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionAddition
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionAddition
	 *     ExpressionLevel2 returns ExpressionAddition
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionAddition
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionAddition
	 *     ExpressionLevel3 returns ExpressionAddition
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionAddition
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionAddition
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionAddition
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionAddition
	 *     ExpressionLevel4 returns ExpressionAddition
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionAddition
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionAddition
	 *
	 * Constraint:
	 *     (left=ExpressionLevel4_ExpressionAddition_1_0_0 right=ExpressionLevel5)
	 */
	protected void sequence_ExpressionLevel4(ISerializationContext context, ExpressionAddition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel4Access().getExpressionAdditionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel4Access().getRightExpressionLevel5ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionSubtraction
	 *     ExpressionLevel1 returns ExpressionSubtraction
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionSubtraction
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionSubtraction
	 *     ExpressionLevel2 returns ExpressionSubtraction
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionSubtraction
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionSubtraction
	 *     ExpressionLevel3 returns ExpressionSubtraction
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionSubtraction
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionSubtraction
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionSubtraction
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionSubtraction
	 *     ExpressionLevel4 returns ExpressionSubtraction
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionSubtraction
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionSubtraction
	 *
	 * Constraint:
	 *     (left=ExpressionLevel4_ExpressionSubtraction_1_1_0 right=ExpressionLevel5)
	 */
	protected void sequence_ExpressionLevel4(ISerializationContext context, ExpressionSubtraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_SUBTRACTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_SUBTRACTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_SUBTRACTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_SUBTRACTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel4Access().getExpressionSubtractionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel4Access().getRightExpressionLevel5ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionDivision
	 *     ExpressionLevel1 returns ExpressionDivision
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel2 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel3 returns ExpressionDivision
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionDivision
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionDivision
	 *     ExpressionLevel4 returns ExpressionDivision
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel5 returns ExpressionDivision
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionDivision
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionDivision
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionDivision
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionDivision
	 *
	 * Constraint:
	 *     (left=ExpressionLevel5_ExpressionDivision_1_1_0 right=ExpressionLevel6)
	 */
	protected void sequence_ExpressionLevel5(ISerializationContext context, ExpressionDivision semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel5Access().getExpressionDivisionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel5Access().getRightExpressionLevel6ParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMaximum
	 *     ExpressionLevel1 returns ExpressionMaximum
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel2 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel3 returns ExpressionMaximum
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionMaximum
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionMaximum
	 *     ExpressionLevel4 returns ExpressionMaximum
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel5 returns ExpressionMaximum
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionMaximum
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionMaximum
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionMaximum
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionMaximum
	 *
	 * Constraint:
	 *     (left=ExpressionLevel5_ExpressionMaximum_1_2_0 right=ExpressionLevel6)
	 */
	protected void sequence_ExpressionLevel5(ISerializationContext context, ExpressionMaximum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MAXIMUM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MAXIMUM__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MAXIMUM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MAXIMUM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel5Access().getExpressionMaximumLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel5Access().getRightExpressionLevel6ParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMinimum
	 *     ExpressionLevel1 returns ExpressionMinimum
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel2 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel3 returns ExpressionMinimum
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionMinimum
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionMinimum
	 *     ExpressionLevel4 returns ExpressionMinimum
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel5 returns ExpressionMinimum
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionMinimum
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionMinimum
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionMinimum
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionMinimum
	 *
	 * Constraint:
	 *     (left=ExpressionLevel5_ExpressionMinimum_1_3_0 right=ExpressionLevel6)
	 */
	protected void sequence_ExpressionLevel5(ISerializationContext context, ExpressionMinimum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINIMUM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINIMUM__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINIMUM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINIMUM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel5Access().getExpressionMinimumLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel5Access().getRightExpressionLevel6ParserRuleCall_1_3_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMultiply
	 *     ExpressionLevel1 returns ExpressionMultiply
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel2 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel3 returns ExpressionMultiply
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionMultiply
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionMultiply
	 *     ExpressionLevel4 returns ExpressionMultiply
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel5 returns ExpressionMultiply
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionMultiply
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionMultiply
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionMultiply
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionMultiply
	 *
	 * Constraint:
	 *     (left=ExpressionLevel5_ExpressionMultiply_1_0_0 right=ExpressionLevel6)
	 */
	protected void sequence_ExpressionLevel5(ISerializationContext context, ExpressionMultiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MULTIPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MULTIPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel5Access().getExpressionMultiplyLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel5Access().getRightExpressionLevel6ParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPower
	 *     ExpressionLevel1 returns ExpressionPower
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionPower
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionPower
	 *     ExpressionLevel2 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionPower
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionPower
	 *     ExpressionLevel3 returns ExpressionPower
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionPower
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionPower
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionPower
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionPower
	 *     ExpressionLevel4 returns ExpressionPower
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionPower
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionPower
	 *     ExpressionLevel5 returns ExpressionPower
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionPower
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionPower
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionPower
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionPower
	 *     ExpressionLevel6 returns ExpressionPower
	 *
	 * Constraint:
	 *     (left=ExpressionLevel6_ExpressionPower_1_0 right=ExpressionLevel6)
	 */
	protected void sequence_ExpressionLevel6(ISerializationContext context, ExpressionPower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_POWER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_POWER__LEFT));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_POWER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_POWER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionLevel6Access().getExpressionPowerLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionLevel6Access().getRightExpressionLevel6ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMinus
	 *     ExpressionLevel1 returns ExpressionMinus
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel2 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel3 returns ExpressionMinus
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionMinus
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionMinus
	 *     ExpressionLevel4 returns ExpressionMinus
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel5 returns ExpressionMinus
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionMinus
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionMinus
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionMinus
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionMinus
	 *     ExpressionLevel6 returns ExpressionMinus
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionMinus
	 *     ExpressionLevel7 returns ExpressionMinus
	 *     ExpressionMinus returns ExpressionMinus
	 *
	 * Constraint:
	 *     sub=ExpressionLevel8
	 */
	protected void sequence_ExpressionMinus(ISerializationContext context, ExpressionMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINUS__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_MINUS__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionMinusAccess().getSubExpressionLevel8ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionNot
	 *     ExpressionLevel1 returns ExpressionNot
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionNot
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionNot
	 *     ExpressionLevel2 returns ExpressionNot
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionNot
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionNot
	 *     ExpressionLevel3 returns ExpressionNot
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionNot
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionNot
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionNot
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionNot
	 *     ExpressionLevel4 returns ExpressionNot
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionNot
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionNot
	 *     ExpressionLevel5 returns ExpressionNot
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionNot
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionNot
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionNot
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionNot
	 *     ExpressionLevel6 returns ExpressionNot
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionNot
	 *     ExpressionLevel7 returns ExpressionNot
	 *     ExpressionNot returns ExpressionNot
	 *
	 * Constraint:
	 *     sub=ExpressionLevel8
	 */
	protected void sequence_ExpressionNot(ISerializationContext context, ExpressionNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_NOT__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_NOT__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionNotAccess().getSubExpressionLevel8ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPlus
	 *     ExpressionLevel1 returns ExpressionPlus
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel2 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel3 returns ExpressionPlus
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionPlus
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionPlus
	 *     ExpressionLevel4 returns ExpressionPlus
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel5 returns ExpressionPlus
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionPlus
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionPlus
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionPlus
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionPlus
	 *     ExpressionLevel6 returns ExpressionPlus
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionPlus
	 *     ExpressionLevel7 returns ExpressionPlus
	 *     ExpressionPlus returns ExpressionPlus
	 *
	 * Constraint:
	 *     sub=ExpressionLevel8
	 */
	protected void sequence_ExpressionPlus(ISerializationContext context, ExpressionPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_PLUS__SUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_PLUS__SUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionPlusAccess().getSubExpressionLevel8ParserRuleCall_1_0(), semanticObject.getSub());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionVariable
	 *     ExpressionLevel1 returns ExpressionVariable
	 *     ExpressionLevel1.ExpressionAnd_1_0_0 returns ExpressionVariable
	 *     ExpressionLevel1.ExpressionOr_1_1_0 returns ExpressionVariable
	 *     ExpressionLevel2 returns ExpressionVariable
	 *     ExpressionLevel2.ExpressionEqual_1_0_0 returns ExpressionVariable
	 *     ExpressionLevel2.ExpressionNEqual_1_1_0 returns ExpressionVariable
	 *     ExpressionLevel3 returns ExpressionVariable
	 *     ExpressionLevel3.ExpressionGeq_1_0_0 returns ExpressionVariable
	 *     ExpressionLevel3.ExpressionGreater_1_1_0 returns ExpressionVariable
	 *     ExpressionLevel3.ExpressionLeq_1_2_0 returns ExpressionVariable
	 *     ExpressionLevel3.ExpressionLess_1_3_0 returns ExpressionVariable
	 *     ExpressionLevel4 returns ExpressionVariable
	 *     ExpressionLevel4.ExpressionAddition_1_0_0 returns ExpressionVariable
	 *     ExpressionLevel4.ExpressionSubtraction_1_1_0 returns ExpressionVariable
	 *     ExpressionLevel5 returns ExpressionVariable
	 *     ExpressionLevel5.ExpressionMultiply_1_0_0 returns ExpressionVariable
	 *     ExpressionLevel5.ExpressionDivision_1_1_0 returns ExpressionVariable
	 *     ExpressionLevel5.ExpressionMaximum_1_2_0 returns ExpressionVariable
	 *     ExpressionLevel5.ExpressionMinimum_1_3_0 returns ExpressionVariable
	 *     ExpressionLevel6 returns ExpressionVariable
	 *     ExpressionLevel6.ExpressionPower_1_0 returns ExpressionVariable
	 *     ExpressionLevel7 returns ExpressionVariable
	 *     ExpressionLevel8 returns ExpressionVariable
	 *     ExpressionVariable returns ExpressionVariable
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_ExpressionVariable(ISerializationContext context, ExpressionVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EXPRESSION_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EXPRESSION_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionVariableAccess().getVariableVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(StateMachinePackage.Literals.EXPRESSION_VARIABLE__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Monitor returns Monitor
	 *
	 * Constraint:
	 *     machines+=StateMachine+
	 */
	protected void sequence_Monitor(ISerializationContext context, Monitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OnFailAction returns RestartPath
	 *     RestartPath returns RestartPath
	 *
	 * Constraint:
	 *     path=INT?
	 */
	protected void sequence_RestartPath(ISerializationContext context, RestartPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OnFailAction returns RestartTask
	 *     RestartTask returns RestartTask
	 *
	 * Constraint:
	 *     {RestartTask}
	 */
	protected void sequence_RestartTask(ISerializationContext context, RestartTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OnFailAction returns SkipPath
	 *     SkipPath returns SkipPath
	 *
	 * Constraint:
	 *     path=INT?
	 */
	protected void sequence_SkipPath(ISerializationContext context, SkipPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OnFailAction returns SkipTask
	 *     SkipTask returns SkipTask
	 *
	 * Constraint:
	 *     {SkipTask}
	 */
	protected void sequence_SkipTask(ISerializationContext context, SkipTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns StartTask
	 *     StartTask returns StartTask
	 *
	 * Constraint:
	 *     (task=ID timeVar=UntypedVariable)
	 */
	protected void sequence_StartTask(ISerializationContext context, StartTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.START_TASK__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.START_TASK__TASK));
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.EVENT__TIME_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartTaskAccess().getTaskIDTerminalRuleCall_2_0(), semanticObject.getTask());
		feeder.accept(grammarAccess.getStartTaskAccess().getTimeVarUntypedVariableParserRuleCall_4_0(), semanticObject.getTimeVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     (name=ID vars+=TypedVariable* states+=State+)
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (initial?='initial'? name=ID transitions+=Transition*)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (event=Event guard=Expression? actions+=Action* onFail=OnFailAction? next=[State|ID])
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns TypedVariable
	 *     TypedVariable returns TypedVariable
	 *
	 * Constraint:
	 *     (type=Type name=ID expr=Expression?)
	 */
	protected void sequence_TypedVariable(ISerializationContext context, TypedVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns UntypedVariable
	 *     UntypedVariable returns UntypedVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_UntypedVariable(ISerializationContext context, UntypedVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StateMachinePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StateMachinePackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUntypedVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
